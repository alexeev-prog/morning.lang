/**
 * Morning.lang grammar (улучшенная версия)
 *
 * Изменения:
 * 1. Добавлена поддержка HEX, OCTAL, BINARY чисел
 * 2. Улучшена читаемость с сохранением структуры
 * 3. Исправлена опечатка в токене STRING -> STRING
 * 4. Явное разделение целых/дробных чисел
 * 5. Добавлена поддержка булевых значений и nil
 * 6. Добавлена обработка escape-последовательностей в строках
 * 7. Расширена поддержка чисел с плавающей точкой
 * 8. Добавлены комментарии к типам данных
 */

%lex

%%

\/\/.*                          %empty
\/\*[\s\S]*?\*\/                %empty

"nil"                           NIL

[-+]?0x[0-9a-fA-F]+             HEX
[-+]?0b[01]+                    BINARY
[-+]?0[0-7]+                    OCTAL

[-+]?\d+\.\d*([eE][-+]?\d+)?    FRACTIONAL
[-+]?\.\d+([eE][-+]?\d+)?       FRACTIONAL
[-+]?\d+[eE][-+]?\d+            FRACTIONAL
[-+]?\d+                        DECIMAL

\s+                             %empty
\"(\\.|[^"\\])*\"               STRING
[\w\-+*=!<>/#]+                 SYMBOL

/lex

%{
#include <string>
#include <vector>
#include <cctype>
#include <cmath>
#include <cstdlib>

enum class ExpType {
    NUMBER,
    FRACTIONAL,
    STRING,
    SYMBOL,
    LIST,
    NIL
};

struct Exp {
    ExpType type;

    int number;
    double fractional;
    std::string string;
    std::vector<Exp> list;

    Exp() : type(ExpType::NIL) {}
    Exp(int number) : type(ExpType::NUMBER), number(number) {}
    Exp(double fractional) : type(ExpType::FRACTIONAL), fractional(fractional) {}

    Exp(std::string& str_value) {
        if (str_value[0] == '"') {
            type = ExpType::STRING;
            string = unescape(str_value.substr(1, str_value.size() - 2));
        } else {
            type = ExpType::SYMBOL;
            string = str_value;
        }
    }

    Exp(std::vector<Exp> list) : type(ExpType::LIST), list(list) {}

private:
    std::string unescape(const std::string& s) {
        std::string result;
        for (size_t i = 0; i < s.length(); ++i) {
            if (s[i] == '\\') {
                switch (s[++i]) {
                    case 'n': result += '\n'; break;
                    case 't': result += '\t'; break;
                    case 'r': result += '\r'; break;
                    case '"': result += '"'; break;
                    case '\\': result += '\\'; break;
                    default: result += '\\' + s[i];
                }
            } else {
                result += s[i];
            }
        }
        return result;
    }
};

using Value = Exp;

int parseInteger(const std::string& str) {
    if (str.empty()) return 0;

    size_t pos = 0;
    int base = 10;
    std::string s = str;

    bool negative = false;
    if (s[0] == '-') {
        negative = true;
        s = s.substr(1);
    } else if (s[0] == '+') {
        s = s.substr(1);
    }

    if (s.size() > 1) {
        if (s[0] == '0') {
            if (s[1] == 'x' || s[1] == 'X') {
                base = 16;
                s = s.substr(2);
            } else if (s[1] == 'b' || s[1] == 'B') {
                base = 2;
                s = s.substr(2);
            } else if (isdigit(s[1])) {
                base = 8;
                s = s.substr(1);
            }
        }
    }

    int value = std::stoi(s, &pos, base);
    return negative ? -value : value;
}

%}

%token HEX
%token BINARY
%token OCTAL
%token DECIMAL
%token FRACTIONAL
%token STRING
%token SYMBOL
%token NIL

%%

Exp
    : Atom
    | List
    ;

Atom
    : DECIMAL   { $$ = Exp(parseInteger($1)) }
    | HEX       { $$ = Exp(parseInteger($1)) }
    | OCTAL     { $$ = Exp(parseInteger($1)) }
    | BINARY    { $$ = Exp(parseInteger($1)) }
    | FRACTIONAL { $$ = Exp(std::stod($1)) }
    | STRING    { $$ = Exp($1) }
    | SYMBOL    { $$ = Exp($1) }
    | NIL       { $$ = Exp() }
    ;

List
    : '[' ListEntries ']' { $$ = $2 }
    | '(' ListEntries ')' { $$ = $2 }
    | '{' ListEntries '}' { $$ = $2 }
    ;

ListEntries
    : %empty { $$ = Exp(std::vector<Exp>{}) }
    | ListEntries Exp { $1.list.push_back($2); $$ = $1 }
    ;
