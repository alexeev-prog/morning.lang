/**
 * LR parser for C++ generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode <parsing-mode> \
 *     --output ~/ParserClassName.h
 */
#ifndef __Syntax_LR_Parser_h
#define __Syntax_LR_Parser_h

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"

#include <array>
#include <iostream>
#include <map>
#include <memory>
#include <regex>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

#include <assert.h>

#include "../logger.hpp"

// ------------------------------------
// Module include prologue.
//
// Should include at least value/result type:
//
// type Value = <...>;
//
// Or struct Value { ... };
//
// Can also include parsing hooks:
//
//   void onParseBegin(const Parser& parser, const std::string& str) {
//     ...
//   }
//
//   void onParseBegin(const Parser& parser, const Value& result) {
//     ...
//   }
//

#include <cctype>
#include <cmath>
#include <cstdlib>
#include <string>
#include <vector>

enum class ExpType
{
    NUMBER,
    FRACTIONAL,
    STRING,
    SYMBOL,
    LIST
};

static inline std::string __EOF("$");

struct Exp {
    ExpType type;

    int line;
    int column;

    int number;
    double fractional;
    std::string string;
    std::vector<Exp> list;

    Exp(int number)
        : type(ExpType::NUMBER)
        , number(number) {}

    Exp(double fractional)
        : type(ExpType::FRACTIONAL)
        , fractional(fractional) {}

    Exp(std::string& str_value) {
        if (str_value[0] == '"') {
            type = ExpType::STRING;
            string = unescape(str_value.substr(1, str_value.size() - 2));
        } else {
            type = ExpType::SYMBOL;
            string = str_value;
        }
    }

    Exp(std::vector<Exp> list)
        : type(ExpType::LIST)
        , list(std::move(list)) {}

    auto to_string() const -> std::string {
        switch (type) {
            case ExpType::NUMBER:
                return std::to_string(number);
            case ExpType::FRACTIONAL:
                return std::to_string(fractional);
            case ExpType::STRING:
                return "\"" + string + "\"";
            case ExpType::SYMBOL:
                return string;
            case ExpType::LIST: {
                std::string result = "[";
                for (size_t i = 0; i < list.size(); ++i) {
                    if (i > 0) {
                        result += " ";
                    }
                    result += list[i].to_string();
                }
                result += "]";
                return result;
            }
        }
        return "unknown";
    }

  private:
    static std::string unescape(const std::string& s) {
        std::string result;
        for (size_t i = 0; i < s.length(); ++i) {
            if (s[i] == '\\') {
                switch (s[++i]) {
                    case 'n':
                        result += '\n';
                        break;
                    case 't':
                        result += '\t';
                        break;
                    case 'r':
                        result += '\r';
                        break;
                    case '"':
                        result += '"';
                        break;
                    case '\\':
                        result += '\\';
                        break;
                    default:
                        result += '\\' + s[i];
                }
            } else {
                result += s[i];
            }
        }
        return result;
    }
};

using Value = Exp;

inline auto parseInteger(const std::string& str) -> int {
    if (str.empty()) {
        return 0;
    }

    size_t pos = 0;
    int base = 10;
    std::string s = str;

    bool negative = false;
    if (s[0] == '-') {
        negative = true;
        s = s.substr(1);
    } else if (s[0] == '+') {
        s = s.substr(1);
    }

    if (s.size() > 1) {
        if (s[0] == '0') {
            if (s[1] == 'x' || s[1] == 'X') {
                base = 16;
                s = s.substr(2);
            } else if (s[1] == 'b' || s[1] == 'B') {
                base = 2;
                s = s.substr(2);
            } else if (isdigit(s[1])) {
                base = 8;
                s = s.substr(1);
            }
        }
    }

    int value = std::stoi(s, &pos, base);
    return negative ? -value : value;
}

namespace syntax {

    /**
     * Tokenizer class.
     */

    /**
     * Generic tokenizer used by the parser in the Syntax tool.
     *
     * https://www.npmjs.com/package/syntax-cli
     */

#ifndef __Syntax_Tokenizer_h
#    define __Syntax_Tokenizer_h

    class Tokenizer;

    // ------------------------------------------------------------------
    // TokenType.

    enum class TokenType
    {
        __EMPTY = -1,

        DECIMAL = 4,
        HEX = 5,
        OCTAL = 6,
        BINARY = 7,
        FRACTIONAL = 8,
        STRING = 9,
        SYMBOL = 10,
        TOKEN_TYPE_11 = 11,
        TOKEN_TYPE_12 = 12,
        TOKEN_TYPE_13 = 13,
        TOKEN_TYPE_14 = 14,
        TOKEN_TYPE_15 = 15,
        TOKEN_TYPE_16 = 16,
        __EOF = 17
    };

    // ------------------------------------------------------------------
    // Token.

    struct Token {
        TokenType type;
        std::string value;

        int startOffset;
        int endOffset;
        int startLine;
        int endLine;
        int startColumn;
        int endColumn;
    };

    using SharedToken = std::shared_ptr<Token>;

    using LexRuleHandler = TokenType (*)(const Tokenizer&, const std::string&);

    // ------------------------------------------------------------------
    // Lex rule: [regex, handler]

    struct LexRule {
        std::regex regex;
        LexRuleHandler handler;
    };

    // ------------------------------------------------------------------
    // Token.

    enum TokenizerState
    {
        INITIAL
    };

    // ------------------------------------------------------------------
    // Tokenizer.

    class Tokenizer {
      public:
        /**
         * Initializes a parsing string.
         */
        void initString(const std::string& str) {
            str_ = str;

            // Initialize states.
            states_.clear();
            states_.push_back(TokenizerState::INITIAL);

            cursor_ = 0;
            currentLine_ = 1;
            currentColumn_ = 0;
            currentLineBeginOffset_ = 0;

            tokenStartOffset_ = 0;
            tokenEndOffset_ = 0;
            tokenStartLine_ = 0;
            tokenEndLine_ = 0;
            tokenStartColumn_ = 0;
            tokenEndColumn_ = 0;
        }

        /**
         * Whether there are still tokens in the stream.
         */
        inline bool hasMoreTokens() { return cursor_ <= str_.length(); }

        /**
         * Returns current tokenizing state.
         */
        TokenizerState getCurrentState() { return states_.back(); }

        /**
         * Enters a new state pushing it on the states stack.
         */
        void pushState(TokenizerState state) { states_.push_back(state); }

        /**
         * Alias for `push_state`.
         */
        void begin(TokenizerState state) { states_.push_back(state); }

        /**
         * Exits a current state popping it from the states stack.
         */
        auto popState() -> TokenizerState {
            auto state = states_.back();
            states_.pop_back();
            return state;
        }

        /**
         * Returns next token.
         */
        auto getNextToken() -> SharedToken {
            if (!hasMoreTokens()) {
                yytext = __EOF;
                return toToken(TokenType::__EOF);
            }

            auto strSlice = str_.substr(cursor_);

            auto lexRulesForState = lexRulesByStartConditions_.at(getCurrentState());

            for (const auto& ruleIndex : lexRulesForState) {
                auto rule = lexRules_[ruleIndex];
                std::smatch sm;

                if (std::regex_search(strSlice, sm, rule.regex)) {
                    yytext = sm[0];

                    captureLocations_(yytext);
                    cursor_ += yytext.length();

                    // Manual handling of EOF token (the end of string). Return it
                    // as `EOF` symbol.
                    if (yytext.length() == 0) {
                        cursor_++;
                    }

                    auto tokenType = rule.handler(*this, yytext);

                    if (tokenType == TokenType::__EMPTY) {
                        return getNextToken();
                    }

                    return toToken(tokenType);
                }
            }

            if (isEOF()) {
                cursor_++;
                yytext = __EOF;
                return toToken(TokenType::__EOF);
            }

            throwUnexpectedToken(std::string(1, strSlice[0]), currentLine_, currentColumn_);
        }

        /**
         * Whether the cursor is at the EOF.
         */
        auto isEOF() -> bool { return cursor_ == str_.length(); }

        auto toToken(TokenType tokenType) -> SharedToken {
            return std::make_shared<Token>(Token {
                .type = tokenType,
                .value = yytext,
                .startOffset = tokenStartOffset_,
                .endOffset = tokenEndOffset_,
                .startLine = tokenStartLine_,
                .endLine = tokenEndLine_,
                .startColumn = tokenStartColumn_,
                .endColumn = tokenEndColumn_,
            });
        }

        /**
         * Throws default "Unexpected token" exception, showing the actual
         * line from the source, pointing with the ^ marker to the bad token.
         * In addition, shows `line:column` location.
         */
        [[noreturn]] void throwUnexpectedToken(const std::string& symbol, int line, int column) {
            std::stringstream ss {str_};
            std::string lineStr;
            int currentLine = 1;

            while (currentLine++ <= line) {
                std::getline(ss, lineStr, '\n');
            }

            auto pad = std::string(column, ' ');

            std::stringstream errMsg;

            std::cerr << errMsg.str();
            LOG_CRITICAL("Syntax Error:\n\n%s\n%s\n^Unexpected token\"%s\" at %d:%d\n\n",
                         lineStr.c_str(),
                         pad.c_str(),
                         symbol.c_str(),
                         line,
                         column);
            // throw new std::runtime_error(errMsg.str().c_str());
        }

        /**
         * Matched text.
         */
        std::string yytext;

      private:
        /**
         * Captures token locations.
         */
        void captureLocations_(const std::string& matched) {
            auto len = matched.length();

            // Absolute offsets.
            tokenStartOffset_ = cursor_;

            // Line-based locations, start.
            tokenStartLine_ = currentLine_;
            tokenStartColumn_ = tokenStartOffset_ - currentLineBeginOffset_;

            // Extract `\n` in the matched token.
            std::stringstream ss {matched};
            std::string lineStr;
            std::getline(ss, lineStr, '\n');
            while (ss.tellg() > 0 && ss.tellg() <= len) {
                currentLine_++;
                currentLineBeginOffset_ = tokenStartOffset_ + ss.tellg();
                std::getline(ss, lineStr, '\n');
            }

            tokenEndOffset_ = cursor_ + len;

            // Line-based locations, end.
            tokenEndLine_ = currentLine_;
            tokenEndColumn_ = tokenEndOffset_ - currentLineBeginOffset_;
            currentColumn_ = tokenEndColumn_;
        }

        /**
         * Lexical rules.
         */

        static constexpr size_t LEX_RULES_COUNT = 18;
        static std::array<LexRule, LEX_RULES_COUNT> lexRules_;
        static std::map<TokenizerState, std::vector<size_t>> lexRulesByStartConditions_;

        /**
         * Special EOF token.
         */
        static std::string __EOF;

        /**
         * Tokenizing string.
         */
        std::string str_;

        /**
         * Cursor for current symbol.
         */
        int cursor_;

        /**
         * States.
         */
        std::vector<TokenizerState> states_;

        /**
         * Line-based location tracking.
         */
        int currentLine_;
        int currentColumn_;
        int currentLineBeginOffset_;

        /**
         * Location data of a matched token.
         */
        int tokenStartOffset_;
        int tokenEndOffset_;
        int tokenStartLine_;
        int tokenEndLine_;
        int tokenStartColumn_;
        int tokenEndColumn_;
    };

    // ------------------------------------------------------------------
    // Lexical rule handlers.

    inline std::string Tokenizer::__EOF("$");

    inline auto _lexRule1(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::TOKEN_TYPE_11;
    }

    inline auto _lexRule2(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::TOKEN_TYPE_12;
    }

    inline auto _lexRule3(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::TOKEN_TYPE_13;
    }

    inline auto _lexRule4(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::TOKEN_TYPE_14;
    }

    inline auto _lexRule5(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::TOKEN_TYPE_15;
    }

    inline auto _lexRule6(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::TOKEN_TYPE_16;
    }

    inline auto _lexRule7(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::__EMPTY;
    }

    inline auto _lexRule8(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::__EMPTY;
    }

    inline auto _lexRule9(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::HEX;
    }

    inline auto _lexRule10(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::BINARY;
    }

    inline auto _lexRule11(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::OCTAL;
    }

    inline auto _lexRule12(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::FRACTIONAL;
    }

    inline auto _lexRule13(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::FRACTIONAL;
    }

    inline auto _lexRule14(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::FRACTIONAL;
    }

    inline auto _lexRule15(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::DECIMAL;
    }

    inline auto _lexRule16(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::__EMPTY;
    }

    inline auto _lexRule17(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::STRING;
    }

    inline auto _lexRule18(const Tokenizer& tokenizer, const std::string& yytext) -> TokenType {
        return TokenType::SYMBOL;
    }

    // ------------------------------------------------------------------
    // Lexical rules.

    inline std::array<LexRule, Tokenizer::LEX_RULES_COUNT> Tokenizer::lexRules_ = {
        {{std::regex(R"(^\[)"), &_lexRule1},
         {std::regex(R"(^\])"), &_lexRule2},
         {std::regex(R"(^\()"), &_lexRule3},
         {std::regex(R"(^\))"), &_lexRule4},
         {std::regex(R"(^\{)"), &_lexRule5},
         {std::regex(R"(^\})"), &_lexRule6},
         {std::regex(R"(^\/\/.*)"), &_lexRule7},
         {std::regex(R"(^\/\*[\s\S]*?\*\/)"), &_lexRule8},
         {std::regex(R"(^[-+]?0x[0-9a-fA-F]+)"), &_lexRule9},
         {std::regex(R"(^[-+]?0b[01]+)"), &_lexRule10},
         {std::regex(R"(^[-+]?0[0-7]+)"), &_lexRule11},
         {std::regex(R"(^[-+]?\d+\.\d*([eE][-+]?\d+)?)"), &_lexRule12},
         {std::regex(R"(^[-+]?\.\d+([eE][-+]?\d+)?)"), &_lexRule13},
         {std::regex(R"(^[-+]?\d+[eE][-+]?\d+)"), &_lexRule14},
         {std::regex(R"(^[-+]?\d+)"), &_lexRule15},
         {std::regex(R"(^\s+)"), &_lexRule16},
         {std::regex(R"(^"(\\.|[^"\\])*")"), &_lexRule17},
         {std::regex(R"(^[\w\-+*=!<>/,:;#]+)"), &_lexRule18}}};
    inline std::map<TokenizerState, std::vector<size_t>> Tokenizer::lexRulesByStartConditions_ = {
        {TokenizerState::INITIAL, {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}}};

#endif

#define POP_V() \
    parser.valuesStack.back(); \
    parser.valuesStack.pop_back()

#define POP_T() \
    parser.tokensStack.back(); \
    parser.tokensStack.pop_back()

#define PUSH_VR() parser.valuesStack.push_back(__)
#define PUSH_TR() parser.tokensStack.push_back(__)

    /**
     * Parsing table type.
     */
    enum class TE
    {
        Accept,
        Shift,
        Reduce,
        Transit,
    };

    /**
     * Parsing table entry.
     */
    struct TableEntry {
        TE type;
        int value;
    };

    class MorningLangGrammar;

    using yyparse = MorningLangGrammar;

    typedef void (*ProductionHandler)(yyparse&);

    /**
     * Encoded production.
     *
     * opcode - encoded index
     * rhsLength - length of the RHS to pop.
     */
    struct Production {
        int opcode;
        int rhsLength;
        ProductionHandler handler;
    };

    // Key: Encoded symbol (terminal or non-terminal) index
    // Value: TableEntry
    using Row = std::map<int, TableEntry>;

    /**
     * Parser class.
     */

    class MorningLangGrammar {
      public:
        /**
         * Parsing values stack.
         */
        std::vector<Value> valuesStack;

        /**
         * Token values stack.
         */
        std::vector<std::string> tokensStack;

        /**
         * Parsing states stack.
         */
        std::vector<int> statesStack;

        /**
         * Tokenizer.
         */
        Tokenizer tokenizer;

        /**
         * Previous state to calculate the next one.
         */
        int previousState;

        /**
         * Parses a string.
         */
        Value parse(const std::string& str) {
            // Initialize the tokenizer and the string.
            tokenizer.initString(str);

            // Initialize the stacks.
            valuesStack.clear();
            tokensStack.clear();
            statesStack.clear();

            // Initial 0 state.
            statesStack.push_back(0);

            auto token = tokenizer.getNextToken();
            auto shiftedToken = token;

            // Main parsing loop.
            for (;;) {
                auto state = statesStack.back();
                auto column = (int)token->type;

                if (table_[state].count(column) == 0) {
                    throwUnexpectedToken(token);
                }

                auto entry = table_[state].at(column);

                // Shift a token, go to state.
                if (entry.type == TE::Shift) {
                    // Push token.
                    tokensStack.push_back(token->value);

                    // Push next state number: "s5" -> 5
                    statesStack.push_back(entry.value);

                    shiftedToken = token;
                    token = tokenizer.getNextToken();
                }

                // Reduce by production.
                else if (entry.type == TE::Reduce)
                {
                    auto productionNumber = entry.value;
                    auto production = Productions[productionNumber];

                    tokenizer.yytext = shiftedToken->value;

                    auto rhsLength = production.rhsLength;
                    while (rhsLength > 0) {
                        statesStack.pop_back();
                        rhsLength--;
                    }

                    // Call the handler.
                    production.handler(*this);

                    auto previousState = statesStack.back();

                    auto symbolToReduceWith = production.opcode;
                    auto nextStateEntry = table_[previousState].at(symbolToReduceWith);
                    assert(nextStateEntry.type == TE::Transit);

                    statesStack.push_back(nextStateEntry.value);
                }

                // Accept the string.
                else if (entry.type == TE::Accept)
                {
                    // Pop state number.
                    statesStack.pop_back();

                    // Pop the parsed value.

                    auto result = valuesStack.back();
                    valuesStack.pop_back();

                    if (statesStack.size() != 1 || statesStack.back() != 0 || tokenizer.hasMoreTokens()) {
                        throwUnexpectedToken(token);
                    }

                    statesStack.pop_back();

                    return result;
                }
            }
        }

      private:
        /**
         * Throws parser error on unexpected token.
         */
        [[noreturn]] void throwUnexpectedToken(SharedToken token) {
            if (token->type == TokenType::__EOF && !tokenizer.hasMoreTokens()) {
                std::string errMsg = "Unexpected end of input.\n";
                std::cerr << errMsg;
                throw std::runtime_error(errMsg.c_str());
            }
            tokenizer.throwUnexpectedToken(token->value, token->startLine, token->startColumn);
        }

        static constexpr size_t PRODUCTIONS_COUNT = 15;
        static std::array<Production, PRODUCTIONS_COUNT> Productions;

        static constexpr size_t ROWS_COUNT = 21;
        static std::array<Row, ROWS_COUNT> table_;
    };

    // ------------------------------------------------------------------
    // Productions.

    inline void _handler1(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_V();

        auto __ = _1;

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler2(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_V();

        auto __ = _1;

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler3(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_V();

        auto __ = _1;

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler4(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_T();

        auto __ = Exp(parseInteger(_1));

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler5(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_T();

        auto __ = Exp(parseInteger(_1));

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler6(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_T();

        auto __ = Exp(parseInteger(_1));

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler7(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_T();

        auto __ = Exp(parseInteger(_1));

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler8(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_T();

        auto __ = Exp(std::stod(_1));

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler9(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_T();

        auto __ = Exp(_1);

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler10(yyparse& parser) {
        // Semantic action prologue.
        auto _1 = POP_T();

        auto __ = Exp(_1);

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler11(yyparse& parser) {
        // Semantic action prologue.
        parser.tokensStack.pop_back();
        auto _2 = POP_V();
        parser.tokensStack.pop_back();

        auto __ = _2;

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler12(yyparse& parser) {
        // Semantic action prologue.
        parser.tokensStack.pop_back();
        auto _2 = POP_V();
        parser.tokensStack.pop_back();

        auto __ = _2;

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler13(yyparse& parser) {
        // Semantic action prologue.
        parser.tokensStack.pop_back();
        auto _2 = POP_V();
        parser.tokensStack.pop_back();

        auto __ = _2;

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler14(yyparse& parser) {
        // Semantic action prologue.

        auto __ = Exp(std::vector<Exp> {});

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline void _handler15(yyparse& parser) {
        // Semantic action prologue.
        auto _2 = POP_V();
        auto _1 = POP_V();

        _1.list.push_back(_2);
        auto __ = _1;

        // Semantic action epilogue.
        PUSH_VR();
    }

    inline std::array<Production, yyparse::PRODUCTIONS_COUNT> yyparse::Productions = {{{-1, 1, &_handler1},
                                                                                       {0, 1, &_handler2},
                                                                                       {0, 1, &_handler3},
                                                                                       {1, 1, &_handler4},
                                                                                       {1, 1, &_handler5},
                                                                                       {1, 1, &_handler6},
                                                                                       {1, 1, &_handler7},
                                                                                       {1, 1, &_handler8},
                                                                                       {1, 1, &_handler9},
                                                                                       {1, 1, &_handler10},
                                                                                       {2, 3, &_handler11},
                                                                                       {2, 3, &_handler12},
                                                                                       {2, 3, &_handler13},
                                                                                       {3, 0, &_handler14},
                                                                                       {3, 2, &_handler15}}};

    // ------------------------------------------------------------------
    // Parsing table.

    inline std::array<Row, yyparse::ROWS_COUNT> yyparse::table_ = {Row {{0, {TE::Transit, 1}},
                                                                        {1, {TE::Transit, 2}},
                                                                        {2, {TE::Transit, 3}},
                                                                        {4, {TE::Shift, 4}},
                                                                        {5, {TE::Shift, 5}},
                                                                        {6, {TE::Shift, 6}},
                                                                        {7, {TE::Shift, 7}},
                                                                        {8, {TE::Shift, 8}},
                                                                        {9, {TE::Shift, 9}},
                                                                        {10, {TE::Shift, 10}},
                                                                        {11, {TE::Shift, 11}},
                                                                        {13, {TE::Shift, 12}},
                                                                        {15, {TE::Shift, 13}}},
                                                                   Row {{17, {TE::Accept, 0}}},
                                                                   Row {{4, {TE::Reduce, 1}},
                                                                        {5, {TE::Reduce, 1}},
                                                                        {6, {TE::Reduce, 1}},
                                                                        {7, {TE::Reduce, 1}},
                                                                        {8, {TE::Reduce, 1}},
                                                                        {9, {TE::Reduce, 1}},
                                                                        {10, {TE::Reduce, 1}},
                                                                        {11, {TE::Reduce, 1}},
                                                                        {12, {TE::Reduce, 1}},
                                                                        {13, {TE::Reduce, 1}},
                                                                        {14, {TE::Reduce, 1}},
                                                                        {15, {TE::Reduce, 1}},
                                                                        {16, {TE::Reduce, 1}},
                                                                        {17, {TE::Reduce, 1}}},
                                                                   Row {{4, {TE::Reduce, 2}},
                                                                        {5, {TE::Reduce, 2}},
                                                                        {6, {TE::Reduce, 2}},
                                                                        {7, {TE::Reduce, 2}},
                                                                        {8, {TE::Reduce, 2}},
                                                                        {9, {TE::Reduce, 2}},
                                                                        {10, {TE::Reduce, 2}},
                                                                        {11, {TE::Reduce, 2}},
                                                                        {12, {TE::Reduce, 2}},
                                                                        {13, {TE::Reduce, 2}},
                                                                        {14, {TE::Reduce, 2}},
                                                                        {15, {TE::Reduce, 2}},
                                                                        {16, {TE::Reduce, 2}},
                                                                        {17, {TE::Reduce, 2}}},
                                                                   Row {{4, {TE::Reduce, 3}},
                                                                        {5, {TE::Reduce, 3}},
                                                                        {6, {TE::Reduce, 3}},
                                                                        {7, {TE::Reduce, 3}},
                                                                        {8, {TE::Reduce, 3}},
                                                                        {9, {TE::Reduce, 3}},
                                                                        {10, {TE::Reduce, 3}},
                                                                        {11, {TE::Reduce, 3}},
                                                                        {12, {TE::Reduce, 3}},
                                                                        {13, {TE::Reduce, 3}},
                                                                        {14, {TE::Reduce, 3}},
                                                                        {15, {TE::Reduce, 3}},
                                                                        {16, {TE::Reduce, 3}},
                                                                        {17, {TE::Reduce, 3}}},
                                                                   Row {{4, {TE::Reduce, 4}},
                                                                        {5, {TE::Reduce, 4}},
                                                                        {6, {TE::Reduce, 4}},
                                                                        {7, {TE::Reduce, 4}},
                                                                        {8, {TE::Reduce, 4}},
                                                                        {9, {TE::Reduce, 4}},
                                                                        {10, {TE::Reduce, 4}},
                                                                        {11, {TE::Reduce, 4}},
                                                                        {12, {TE::Reduce, 4}},
                                                                        {13, {TE::Reduce, 4}},
                                                                        {14, {TE::Reduce, 4}},
                                                                        {15, {TE::Reduce, 4}},
                                                                        {16, {TE::Reduce, 4}},
                                                                        {17, {TE::Reduce, 4}}},
                                                                   Row {{4, {TE::Reduce, 5}},
                                                                        {5, {TE::Reduce, 5}},
                                                                        {6, {TE::Reduce, 5}},
                                                                        {7, {TE::Reduce, 5}},
                                                                        {8, {TE::Reduce, 5}},
                                                                        {9, {TE::Reduce, 5}},
                                                                        {10, {TE::Reduce, 5}},
                                                                        {11, {TE::Reduce, 5}},
                                                                        {12, {TE::Reduce, 5}},
                                                                        {13, {TE::Reduce, 5}},
                                                                        {14, {TE::Reduce, 5}},
                                                                        {15, {TE::Reduce, 5}},
                                                                        {16, {TE::Reduce, 5}},
                                                                        {17, {TE::Reduce, 5}}},
                                                                   Row {{4, {TE::Reduce, 6}},
                                                                        {5, {TE::Reduce, 6}},
                                                                        {6, {TE::Reduce, 6}},
                                                                        {7, {TE::Reduce, 6}},
                                                                        {8, {TE::Reduce, 6}},
                                                                        {9, {TE::Reduce, 6}},
                                                                        {10, {TE::Reduce, 6}},
                                                                        {11, {TE::Reduce, 6}},
                                                                        {12, {TE::Reduce, 6}},
                                                                        {13, {TE::Reduce, 6}},
                                                                        {14, {TE::Reduce, 6}},
                                                                        {15, {TE::Reduce, 6}},
                                                                        {16, {TE::Reduce, 6}},
                                                                        {17, {TE::Reduce, 6}}},
                                                                   Row {{4, {TE::Reduce, 7}},
                                                                        {5, {TE::Reduce, 7}},
                                                                        {6, {TE::Reduce, 7}},
                                                                        {7, {TE::Reduce, 7}},
                                                                        {8, {TE::Reduce, 7}},
                                                                        {9, {TE::Reduce, 7}},
                                                                        {10, {TE::Reduce, 7}},
                                                                        {11, {TE::Reduce, 7}},
                                                                        {12, {TE::Reduce, 7}},
                                                                        {13, {TE::Reduce, 7}},
                                                                        {14, {TE::Reduce, 7}},
                                                                        {15, {TE::Reduce, 7}},
                                                                        {16, {TE::Reduce, 7}},
                                                                        {17, {TE::Reduce, 7}}},
                                                                   Row {{4, {TE::Reduce, 8}},
                                                                        {5, {TE::Reduce, 8}},
                                                                        {6, {TE::Reduce, 8}},
                                                                        {7, {TE::Reduce, 8}},
                                                                        {8, {TE::Reduce, 8}},
                                                                        {9, {TE::Reduce, 8}},
                                                                        {10, {TE::Reduce, 8}},
                                                                        {11, {TE::Reduce, 8}},
                                                                        {12, {TE::Reduce, 8}},
                                                                        {13, {TE::Reduce, 8}},
                                                                        {14, {TE::Reduce, 8}},
                                                                        {15, {TE::Reduce, 8}},
                                                                        {16, {TE::Reduce, 8}},
                                                                        {17, {TE::Reduce, 8}}},
                                                                   Row {{4, {TE::Reduce, 9}},
                                                                        {5, {TE::Reduce, 9}},
                                                                        {6, {TE::Reduce, 9}},
                                                                        {7, {TE::Reduce, 9}},
                                                                        {8, {TE::Reduce, 9}},
                                                                        {9, {TE::Reduce, 9}},
                                                                        {10, {TE::Reduce, 9}},
                                                                        {11, {TE::Reduce, 9}},
                                                                        {12, {TE::Reduce, 9}},
                                                                        {13, {TE::Reduce, 9}},
                                                                        {14, {TE::Reduce, 9}},
                                                                        {15, {TE::Reduce, 9}},
                                                                        {16, {TE::Reduce, 9}},
                                                                        {17, {TE::Reduce, 9}}},
                                                                   Row {{3, {TE::Transit, 14}},
                                                                        {4, {TE::Reduce, 13}},
                                                                        {5, {TE::Reduce, 13}},
                                                                        {6, {TE::Reduce, 13}},
                                                                        {7, {TE::Reduce, 13}},
                                                                        {8, {TE::Reduce, 13}},
                                                                        {9, {TE::Reduce, 13}},
                                                                        {10, {TE::Reduce, 13}},
                                                                        {11, {TE::Reduce, 13}},
                                                                        {12, {TE::Reduce, 13}},
                                                                        {13, {TE::Reduce, 13}},
                                                                        {15, {TE::Reduce, 13}}},
                                                                   Row {{3, {TE::Transit, 17}},
                                                                        {4, {TE::Reduce, 13}},
                                                                        {5, {TE::Reduce, 13}},
                                                                        {6, {TE::Reduce, 13}},
                                                                        {7, {TE::Reduce, 13}},
                                                                        {8, {TE::Reduce, 13}},
                                                                        {9, {TE::Reduce, 13}},
                                                                        {10, {TE::Reduce, 13}},
                                                                        {11, {TE::Reduce, 13}},
                                                                        {13, {TE::Reduce, 13}},
                                                                        {14, {TE::Reduce, 13}},
                                                                        {15, {TE::Reduce, 13}}},
                                                                   Row {{3, {TE::Transit, 19}},
                                                                        {4, {TE::Reduce, 13}},
                                                                        {5, {TE::Reduce, 13}},
                                                                        {6, {TE::Reduce, 13}},
                                                                        {7, {TE::Reduce, 13}},
                                                                        {8, {TE::Reduce, 13}},
                                                                        {9, {TE::Reduce, 13}},
                                                                        {10, {TE::Reduce, 13}},
                                                                        {11, {TE::Reduce, 13}},
                                                                        {13, {TE::Reduce, 13}},
                                                                        {15, {TE::Reduce, 13}},
                                                                        {16, {TE::Reduce, 13}}},
                                                                   Row {{0, {TE::Transit, 16}},
                                                                        {1, {TE::Transit, 2}},
                                                                        {2, {TE::Transit, 3}},
                                                                        {4, {TE::Shift, 4}},
                                                                        {5, {TE::Shift, 5}},
                                                                        {6, {TE::Shift, 6}},
                                                                        {7, {TE::Shift, 7}},
                                                                        {8, {TE::Shift, 8}},
                                                                        {9, {TE::Shift, 9}},
                                                                        {10, {TE::Shift, 10}},
                                                                        {11, {TE::Shift, 11}},
                                                                        {12, {TE::Shift, 15}},
                                                                        {13, {TE::Shift, 12}},
                                                                        {15, {TE::Shift, 13}}},
                                                                   Row {{4, {TE::Reduce, 10}},
                                                                        {5, {TE::Reduce, 10}},
                                                                        {6, {TE::Reduce, 10}},
                                                                        {7, {TE::Reduce, 10}},
                                                                        {8, {TE::Reduce, 10}},
                                                                        {9, {TE::Reduce, 10}},
                                                                        {10, {TE::Reduce, 10}},
                                                                        {11, {TE::Reduce, 10}},
                                                                        {12, {TE::Reduce, 10}},
                                                                        {13, {TE::Reduce, 10}},
                                                                        {14, {TE::Reduce, 10}},
                                                                        {15, {TE::Reduce, 10}},
                                                                        {16, {TE::Reduce, 10}},
                                                                        {17, {TE::Reduce, 10}}},
                                                                   Row {{4, {TE::Reduce, 14}},
                                                                        {5, {TE::Reduce, 14}},
                                                                        {6, {TE::Reduce, 14}},
                                                                        {7, {TE::Reduce, 14}},
                                                                        {8, {TE::Reduce, 14}},
                                                                        {9, {TE::Reduce, 14}},
                                                                        {10, {TE::Reduce, 14}},
                                                                        {11, {TE::Reduce, 14}},
                                                                        {12, {TE::Reduce, 14}},
                                                                        {13, {TE::Reduce, 14}},
                                                                        {14, {TE::Reduce, 14}},
                                                                        {15, {TE::Reduce, 14}},
                                                                        {16, {TE::Reduce, 14}}},
                                                                   Row {{0, {TE::Transit, 16}},
                                                                        {1, {TE::Transit, 2}},
                                                                        {2, {TE::Transit, 3}},
                                                                        {4, {TE::Shift, 4}},
                                                                        {5, {TE::Shift, 5}},
                                                                        {6, {TE::Shift, 6}},
                                                                        {7, {TE::Shift, 7}},
                                                                        {8, {TE::Shift, 8}},
                                                                        {9, {TE::Shift, 9}},
                                                                        {10, {TE::Shift, 10}},
                                                                        {11, {TE::Shift, 11}},
                                                                        {13, {TE::Shift, 12}},
                                                                        {14, {TE::Shift, 18}},
                                                                        {15, {TE::Shift, 13}}},
                                                                   Row {{4, {TE::Reduce, 11}},
                                                                        {5, {TE::Reduce, 11}},
                                                                        {6, {TE::Reduce, 11}},
                                                                        {7, {TE::Reduce, 11}},
                                                                        {8, {TE::Reduce, 11}},
                                                                        {9, {TE::Reduce, 11}},
                                                                        {10, {TE::Reduce, 11}},
                                                                        {11, {TE::Reduce, 11}},
                                                                        {12, {TE::Reduce, 11}},
                                                                        {13, {TE::Reduce, 11}},
                                                                        {14, {TE::Reduce, 11}},
                                                                        {15, {TE::Reduce, 11}},
                                                                        {16, {TE::Reduce, 11}},
                                                                        {17, {TE::Reduce, 11}}},
                                                                   Row {{0, {TE::Transit, 16}},
                                                                        {1, {TE::Transit, 2}},
                                                                        {2, {TE::Transit, 3}},
                                                                        {4, {TE::Shift, 4}},
                                                                        {5, {TE::Shift, 5}},
                                                                        {6, {TE::Shift, 6}},
                                                                        {7, {TE::Shift, 7}},
                                                                        {8, {TE::Shift, 8}},
                                                                        {9, {TE::Shift, 9}},
                                                                        {10, {TE::Shift, 10}},
                                                                        {11, {TE::Shift, 11}},
                                                                        {13, {TE::Shift, 12}},
                                                                        {15, {TE::Shift, 13}},
                                                                        {16, {TE::Shift, 20}}},
                                                                   Row {{4, {TE::Reduce, 12}},
                                                                        {5, {TE::Reduce, 12}},
                                                                        {6, {TE::Reduce, 12}},
                                                                        {7, {TE::Reduce, 12}},
                                                                        {8, {TE::Reduce, 12}},
                                                                        {9, {TE::Reduce, 12}},
                                                                        {10, {TE::Reduce, 12}},
                                                                        {11, {TE::Reduce, 12}},
                                                                        {12, {TE::Reduce, 12}},
                                                                        {13, {TE::Reduce, 12}},
                                                                        {14, {TE::Reduce, 12}},
                                                                        {15, {TE::Reduce, 12}},
                                                                        {16, {TE::Reduce, 12}},
                                                                        {17, {TE::Reduce, 12}}}};

}    // namespace syntax

#endif
